// generated by "charlatan -output=./mock/mock.go -package=authenticatorMock Authenticator".  DO NOT EDIT.

package authenticatorMock

import "reflect"

// AuthenticatorGetTokenInvocation represents a single call of FakeAuthenticator.GetToken
type AuthenticatorGetTokenInvocation struct {
	Parameters struct {
		Scope string
	}
	Results struct {
		Token string
		Err   error
	}
}

// NewAuthenticatorGetTokenInvocation creates a new instance of AuthenticatorGetTokenInvocation
func NewAuthenticatorGetTokenInvocation(scope string, token string, err error) *AuthenticatorGetTokenInvocation {
	invocation := new(AuthenticatorGetTokenInvocation)

	invocation.Parameters.Scope = scope

	invocation.Results.Token = token
	invocation.Results.Err = err

	return invocation
}

// AuthenticatorTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type AuthenticatorTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeAuthenticator is a mock implementation of Authenticator for testing.
Use it in your tests as in this example:

	package example

	func TestWithAuthenticator(t *testing.T) {
		f := &authenticatorMock.FakeAuthenticator{
			GetTokenHook: func(scope string) (token string, err error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeGetToken ...
		f.AssertGetTokenCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeGetToken.
*/
type FakeAuthenticator struct {
	GetTokenHook func(string) (string, error)

	GetTokenCalls []*AuthenticatorGetTokenInvocation
}

// NewFakeAuthenticatorDefaultPanic returns an instance of FakeAuthenticator with all hooks configured to panic
func NewFakeAuthenticatorDefaultPanic() *FakeAuthenticator {
	return &FakeAuthenticator{
		GetTokenHook: func(string) (token string, err error) {
			panic("Unexpected call to Authenticator.GetToken")
		},
	}
}

// NewFakeAuthenticatorDefaultFatal returns an instance of FakeAuthenticator with all hooks configured to call t.Fatal
func NewFakeAuthenticatorDefaultFatal(t_sym1 AuthenticatorTestingT) *FakeAuthenticator {
	return &FakeAuthenticator{
		GetTokenHook: func(string) (token string, err error) {
			t_sym1.Fatal("Unexpected call to Authenticator.GetToken")
			return
		},
	}
}

// NewFakeAuthenticatorDefaultError returns an instance of FakeAuthenticator with all hooks configured to call t.Error
func NewFakeAuthenticatorDefaultError(t_sym2 AuthenticatorTestingT) *FakeAuthenticator {
	return &FakeAuthenticator{
		GetTokenHook: func(string) (token string, err error) {
			t_sym2.Error("Unexpected call to Authenticator.GetToken")
			return
		},
	}
}

func (f *FakeAuthenticator) Reset() {
	f.GetTokenCalls = []*AuthenticatorGetTokenInvocation{}
}

func (f_sym3 *FakeAuthenticator) GetToken(scope string) (token string, err error) {
	if f_sym3.GetTokenHook == nil {
		panic("Authenticator.GetToken() called but FakeAuthenticator.GetTokenHook is nil")
	}

	invocation_sym3 := new(AuthenticatorGetTokenInvocation)
	f_sym3.GetTokenCalls = append(f_sym3.GetTokenCalls, invocation_sym3)

	invocation_sym3.Parameters.Scope = scope

	token, err = f_sym3.GetTokenHook(scope)

	invocation_sym3.Results.Token = token
	invocation_sym3.Results.Err = err

	return
}

// SetGetTokenStub configures Authenticator.GetToken to always return the given values
func (f_sym4 *FakeAuthenticator) SetGetTokenStub(token string, err error) {
	f_sym4.GetTokenHook = func(string) (string, error) {
		return token, err
	}
}

// SetGetTokenInvocation configures Authenticator.GetToken to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeAuthenticator) SetGetTokenInvocation(calls_sym5 []*AuthenticatorGetTokenInvocation, fallback_sym5 func() (string, error)) {
	f_sym5.GetTokenHook = func(scope string) (token string, err error) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Scope, scope) {
				token = call_sym5.Results.Token
				err = call_sym5.Results.Err

				return
			}
		}

		return fallback_sym5()
	}
}

// GetTokenCalled returns true if FakeAuthenticator.GetToken was called
func (f *FakeAuthenticator) GetTokenCalled() bool {
	return len(f.GetTokenCalls) != 0
}

// AssertGetTokenCalled calls t.Error if FakeAuthenticator.GetToken was not called
func (f *FakeAuthenticator) AssertGetTokenCalled(t AuthenticatorTestingT) {
	t.Helper()
	if len(f.GetTokenCalls) == 0 {
		t.Error("FakeAuthenticator.GetToken not called, expected at least one")
	}
}

// GetTokenNotCalled returns true if FakeAuthenticator.GetToken was not called
func (f *FakeAuthenticator) GetTokenNotCalled() bool {
	return len(f.GetTokenCalls) == 0
}

// AssertGetTokenNotCalled calls t.Error if FakeAuthenticator.GetToken was called
func (f *FakeAuthenticator) AssertGetTokenNotCalled(t AuthenticatorTestingT) {
	t.Helper()
	if len(f.GetTokenCalls) != 0 {
		t.Error("FakeAuthenticator.GetToken called, expected none")
	}
}

// GetTokenCalledOnce returns true if FakeAuthenticator.GetToken was called exactly once
func (f *FakeAuthenticator) GetTokenCalledOnce() bool {
	return len(f.GetTokenCalls) == 1
}

// AssertGetTokenCalledOnce calls t.Error if FakeAuthenticator.GetToken was not called exactly once
func (f *FakeAuthenticator) AssertGetTokenCalledOnce(t AuthenticatorTestingT) {
	t.Helper()
	if len(f.GetTokenCalls) != 1 {
		t.Errorf("FakeAuthenticator.GetToken called %d times, expected 1", len(f.GetTokenCalls))
	}
}

// GetTokenCalledN returns true if FakeAuthenticator.GetToken was called at least n times
func (f *FakeAuthenticator) GetTokenCalledN(n int) bool {
	return len(f.GetTokenCalls) >= n
}

// AssertGetTokenCalledN calls t.Error if FakeAuthenticator.GetToken was called less than n times
func (f *FakeAuthenticator) AssertGetTokenCalledN(t AuthenticatorTestingT, n int) {
	t.Helper()
	if len(f.GetTokenCalls) < n {
		t.Errorf("FakeAuthenticator.GetToken called %d times, expected >= %d", len(f.GetTokenCalls), n)
	}
}

// GetTokenCalledWith returns true if FakeAuthenticator.GetToken was called with the given values
func (f_sym6 *FakeAuthenticator) GetTokenCalledWith(scope string) bool {
	for _, call_sym6 := range f_sym6.GetTokenCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Scope, scope) {
			return true
		}
	}

	return false
}

// AssertGetTokenCalledWith calls t.Error if FakeAuthenticator.GetToken was not called with the given values
func (f_sym7 *FakeAuthenticator) AssertGetTokenCalledWith(t AuthenticatorTestingT, scope string) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.GetTokenCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Scope, scope) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeAuthenticator.GetToken not called with expected parameters")
	}
}

// GetTokenCalledOnceWith returns true if FakeAuthenticator.GetToken was called exactly once with the given values
func (f_sym8 *FakeAuthenticator) GetTokenCalledOnceWith(scope string) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.GetTokenCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Scope, scope) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertGetTokenCalledOnceWith calls t.Error if FakeAuthenticator.GetToken was not called exactly once with the given values
func (f_sym9 *FakeAuthenticator) AssertGetTokenCalledOnceWith(t AuthenticatorTestingT, scope string) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.GetTokenCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Scope, scope) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeAuthenticator.GetToken called %d times with expected parameters, expected one", count_sym9)
	}
}

// GetTokenResultsForCall returns the result values for the first call to FakeAuthenticator.GetToken with the given values
func (f_sym10 *FakeAuthenticator) GetTokenResultsForCall(scope string) (token string, err error, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.GetTokenCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Scope, scope) {
			token = call_sym10.Results.Token
			err = call_sym10.Results.Err
			found_sym10 = true
			break
		}
	}

	return
}
