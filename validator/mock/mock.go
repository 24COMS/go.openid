// generated by "charlatan -output=./mock/mock.go -package=validatorMock Validator".  DO NOT EDIT.

package validatorMock

import "reflect"
import "crypto/rsa"
import (
	"github.com/24COMS/go.openid/validator"
	"github.com/SermoDigital/jose/jwt"
)

// ValidatorCheckRSAExpirationInvocation represents a single call of FakeValidator.CheckRSAExpiration
type ValidatorCheckRSAExpirationInvocation struct {
	Results struct {
		Ident1 error
	}
}

// ValidatorGetRSAPubKeysInvocation represents a single call of FakeValidator.GetRSAPubKeys
type ValidatorGetRSAPubKeysInvocation struct {
	Results struct {
		Ident1 []*rsa.PublicKey
	}
}

// ValidatorValidateApplicationTokenInvocation represents a single call of FakeValidator.ValidateApplicationToken
type ValidatorValidateApplicationTokenInvocation struct {
	Parameters struct {
		AccessToken    string
		RequiredScopes []string
	}
	Results struct {
		Ident1 bool
		Ident2 error
	}
}

// NewValidatorValidateApplicationTokenInvocation creates a new instance of ValidatorValidateApplicationTokenInvocation
func NewValidatorValidateApplicationTokenInvocation(accessToken string, requiredScopes []string, ident1 bool, ident2 error) *ValidatorValidateApplicationTokenInvocation {
	invocation := new(ValidatorValidateApplicationTokenInvocation)

	invocation.Parameters.AccessToken = accessToken
	invocation.Parameters.RequiredScopes = requiredScopes

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// ValidatorGetAndValidateTokenInvocation represents a single call of FakeValidator.GetAndValidateToken
type ValidatorGetAndValidateTokenInvocation struct {
	Parameters struct {
		AccessToken    string
		RequiredScopes []string
	}
	Results struct {
		Ident1 jwt.JWT
		Ident2 error
	}
}

// NewValidatorGetAndValidateTokenInvocation creates a new instance of ValidatorGetAndValidateTokenInvocation
func NewValidatorGetAndValidateTokenInvocation(accessToken string, requiredScopes []string, ident1 jwt.JWT, ident2 error) *ValidatorGetAndValidateTokenInvocation {
	invocation := new(ValidatorGetAndValidateTokenInvocation)

	invocation.Parameters.AccessToken = accessToken
	invocation.Parameters.RequiredScopes = requiredScopes

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// ValidatorValidateUserTokenInvocation represents a single call of FakeValidator.ValidateUserToken
type ValidatorValidateUserTokenInvocation struct {
	Parameters struct {
		AccessToken    string
		RequiredScopes []string
	}
	Results struct {
		Ident1 uint64
		Ident2 uint64
		Ident3 bool
		Ident4 error
	}
}

// NewValidatorValidateUserTokenInvocation creates a new instance of ValidatorValidateUserTokenInvocation
func NewValidatorValidateUserTokenInvocation(accessToken string, requiredScopes []string, ident1 uint64, ident2 uint64, ident3 bool, ident4 error) *ValidatorValidateUserTokenInvocation {
	invocation := new(ValidatorValidateUserTokenInvocation)

	invocation.Parameters.AccessToken = accessToken
	invocation.Parameters.RequiredScopes = requiredScopes

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3
	invocation.Results.Ident4 = ident4

	return invocation
}

// ValidatorGetOpenIDConfigInvocation represents a single call of FakeValidator.GetOpenIDConfig
type ValidatorGetOpenIDConfigInvocation struct {
	Results struct {
		Ident1 access.OpenIDConfig
	}
}

// ValidatorTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ValidatorTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeValidator is a mock implementation of Validator for testing.
Use it in your tests as in this example:

	package example

	func TestWithValidator(t *testing.T) {
		f := &validatorMock.FakeValidator{
			CheckRSAExpirationHook: func() (ident1 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeCheckRSAExpiration ...
		f.AssertCheckRSAExpirationCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeCheckRSAExpiration.
*/
type FakeValidator struct {
	CheckRSAExpirationHook       func() error
	GetRSAPubKeysHook            func() []*rsa.PublicKey
	ValidateApplicationTokenHook func(string, ...string) (bool, error)
	GetAndValidateTokenHook      func(string, ...string) (jwt.JWT, error)
	ValidateUserTokenHook        func(string, ...string) (uint64, uint64, bool, error)
	GetOpenIDConfigHook          func() access.OpenIDConfig

	CheckRSAExpirationCalls       []*ValidatorCheckRSAExpirationInvocation
	GetRSAPubKeysCalls            []*ValidatorGetRSAPubKeysInvocation
	ValidateApplicationTokenCalls []*ValidatorValidateApplicationTokenInvocation
	GetAndValidateTokenCalls      []*ValidatorGetAndValidateTokenInvocation
	ValidateUserTokenCalls        []*ValidatorValidateUserTokenInvocation
	GetOpenIDConfigCalls          []*ValidatorGetOpenIDConfigInvocation
}

// NewFakeValidatorDefaultPanic returns an instance of FakeValidator with all hooks configured to panic
func NewFakeValidatorDefaultPanic() *FakeValidator {
	return &FakeValidator{
		CheckRSAExpirationHook: func() (ident1 error) {
			panic("Unexpected call to Validator.CheckRSAExpiration")
		},
		GetRSAPubKeysHook: func() (ident1 []*rsa.PublicKey) {
			panic("Unexpected call to Validator.GetRSAPubKeys")
		},
		ValidateApplicationTokenHook: func(string, ...string) (ident1 bool, ident2 error) {
			panic("Unexpected call to Validator.ValidateApplicationToken")
		},
		GetAndValidateTokenHook: func(string, ...string) (ident1 jwt.JWT, ident2 error) {
			panic("Unexpected call to Validator.GetAndValidateToken")
		},
		ValidateUserTokenHook: func(string, ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
			panic("Unexpected call to Validator.ValidateUserToken")
		},
		GetOpenIDConfigHook: func() (ident1 access.OpenIDConfig) {
			panic("Unexpected call to Validator.GetOpenIDConfig")
		},
	}
}

// NewFakeValidatorDefaultFatal returns an instance of FakeValidator with all hooks configured to call t.Fatal
func NewFakeValidatorDefaultFatal(t_sym1 ValidatorTestingT) *FakeValidator {
	return &FakeValidator{
		CheckRSAExpirationHook: func() (ident1 error) {
			t_sym1.Fatal("Unexpected call to Validator.CheckRSAExpiration")
			return
		},
		GetRSAPubKeysHook: func() (ident1 []*rsa.PublicKey) {
			t_sym1.Fatal("Unexpected call to Validator.GetRSAPubKeys")
			return
		},
		ValidateApplicationTokenHook: func(string, ...string) (ident1 bool, ident2 error) {
			t_sym1.Fatal("Unexpected call to Validator.ValidateApplicationToken")
			return
		},
		GetAndValidateTokenHook: func(string, ...string) (ident1 jwt.JWT, ident2 error) {
			t_sym1.Fatal("Unexpected call to Validator.GetAndValidateToken")
			return
		},
		ValidateUserTokenHook: func(string, ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
			t_sym1.Fatal("Unexpected call to Validator.ValidateUserToken")
			return
		},
		GetOpenIDConfigHook: func() (ident1 access.OpenIDConfig) {
			t_sym1.Fatal("Unexpected call to Validator.GetOpenIDConfig")
			return
		},
	}
}

// NewFakeValidatorDefaultError returns an instance of FakeValidator with all hooks configured to call t.Error
func NewFakeValidatorDefaultError(t_sym2 ValidatorTestingT) *FakeValidator {
	return &FakeValidator{
		CheckRSAExpirationHook: func() (ident1 error) {
			t_sym2.Error("Unexpected call to Validator.CheckRSAExpiration")
			return
		},
		GetRSAPubKeysHook: func() (ident1 []*rsa.PublicKey) {
			t_sym2.Error("Unexpected call to Validator.GetRSAPubKeys")
			return
		},
		ValidateApplicationTokenHook: func(string, ...string) (ident1 bool, ident2 error) {
			t_sym2.Error("Unexpected call to Validator.ValidateApplicationToken")
			return
		},
		GetAndValidateTokenHook: func(string, ...string) (ident1 jwt.JWT, ident2 error) {
			t_sym2.Error("Unexpected call to Validator.GetAndValidateToken")
			return
		},
		ValidateUserTokenHook: func(string, ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
			t_sym2.Error("Unexpected call to Validator.ValidateUserToken")
			return
		},
		GetOpenIDConfigHook: func() (ident1 access.OpenIDConfig) {
			t_sym2.Error("Unexpected call to Validator.GetOpenIDConfig")
			return
		},
	}
}

func (f *FakeValidator) Reset() {
	f.CheckRSAExpirationCalls = []*ValidatorCheckRSAExpirationInvocation{}
	f.GetRSAPubKeysCalls = []*ValidatorGetRSAPubKeysInvocation{}
	f.ValidateApplicationTokenCalls = []*ValidatorValidateApplicationTokenInvocation{}
	f.GetAndValidateTokenCalls = []*ValidatorGetAndValidateTokenInvocation{}
	f.ValidateUserTokenCalls = []*ValidatorValidateUserTokenInvocation{}
	f.GetOpenIDConfigCalls = []*ValidatorGetOpenIDConfigInvocation{}
}

func (f_sym3 *FakeValidator) CheckRSAExpiration() (ident1 error) {
	if f_sym3.CheckRSAExpirationHook == nil {
		panic("Validator.CheckRSAExpiration() called but FakeValidator.CheckRSAExpirationHook is nil")
	}

	invocation_sym3 := new(ValidatorCheckRSAExpirationInvocation)
	f_sym3.CheckRSAExpirationCalls = append(f_sym3.CheckRSAExpirationCalls, invocation_sym3)

	ident1 = f_sym3.CheckRSAExpirationHook()

	invocation_sym3.Results.Ident1 = ident1

	return
}

// SetCheckRSAExpirationStub configures Validator.CheckRSAExpiration to always return the given values
func (f_sym4 *FakeValidator) SetCheckRSAExpirationStub(ident1 error) {
	f_sym4.CheckRSAExpirationHook = func() error {
		return ident1
	}
}

// CheckRSAExpirationCalled returns true if FakeValidator.CheckRSAExpiration was called
func (f *FakeValidator) CheckRSAExpirationCalled() bool {
	return len(f.CheckRSAExpirationCalls) != 0
}

// AssertCheckRSAExpirationCalled calls t.Error if FakeValidator.CheckRSAExpiration was not called
func (f *FakeValidator) AssertCheckRSAExpirationCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.CheckRSAExpirationCalls) == 0 {
		t.Error("FakeValidator.CheckRSAExpiration not called, expected at least one")
	}
}

// CheckRSAExpirationNotCalled returns true if FakeValidator.CheckRSAExpiration was not called
func (f *FakeValidator) CheckRSAExpirationNotCalled() bool {
	return len(f.CheckRSAExpirationCalls) == 0
}

// AssertCheckRSAExpirationNotCalled calls t.Error if FakeValidator.CheckRSAExpiration was called
func (f *FakeValidator) AssertCheckRSAExpirationNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.CheckRSAExpirationCalls) != 0 {
		t.Error("FakeValidator.CheckRSAExpiration called, expected none")
	}
}

// CheckRSAExpirationCalledOnce returns true if FakeValidator.CheckRSAExpiration was called exactly once
func (f *FakeValidator) CheckRSAExpirationCalledOnce() bool {
	return len(f.CheckRSAExpirationCalls) == 1
}

// AssertCheckRSAExpirationCalledOnce calls t.Error if FakeValidator.CheckRSAExpiration was not called exactly once
func (f *FakeValidator) AssertCheckRSAExpirationCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.CheckRSAExpirationCalls) != 1 {
		t.Errorf("FakeValidator.CheckRSAExpiration called %d times, expected 1", len(f.CheckRSAExpirationCalls))
	}
}

// CheckRSAExpirationCalledN returns true if FakeValidator.CheckRSAExpiration was called at least n times
func (f *FakeValidator) CheckRSAExpirationCalledN(n int) bool {
	return len(f.CheckRSAExpirationCalls) >= n
}

// AssertCheckRSAExpirationCalledN calls t.Error if FakeValidator.CheckRSAExpiration was called less than n times
func (f *FakeValidator) AssertCheckRSAExpirationCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.CheckRSAExpirationCalls) < n {
		t.Errorf("FakeValidator.CheckRSAExpiration called %d times, expected >= %d", len(f.CheckRSAExpirationCalls), n)
	}
}

func (f_sym5 *FakeValidator) GetRSAPubKeys() (ident1 []*rsa.PublicKey) {
	if f_sym5.GetRSAPubKeysHook == nil {
		panic("Validator.GetRSAPubKeys() called but FakeValidator.GetRSAPubKeysHook is nil")
	}

	invocation_sym5 := new(ValidatorGetRSAPubKeysInvocation)
	f_sym5.GetRSAPubKeysCalls = append(f_sym5.GetRSAPubKeysCalls, invocation_sym5)

	ident1 = f_sym5.GetRSAPubKeysHook()

	invocation_sym5.Results.Ident1 = ident1

	return
}

// SetGetRSAPubKeysStub configures Validator.GetRSAPubKeys to always return the given values
func (f_sym6 *FakeValidator) SetGetRSAPubKeysStub(ident1 []*rsa.PublicKey) {
	f_sym6.GetRSAPubKeysHook = func() []*rsa.PublicKey {
		return ident1
	}
}

// GetRSAPubKeysCalled returns true if FakeValidator.GetRSAPubKeys was called
func (f *FakeValidator) GetRSAPubKeysCalled() bool {
	return len(f.GetRSAPubKeysCalls) != 0
}

// AssertGetRSAPubKeysCalled calls t.Error if FakeValidator.GetRSAPubKeys was not called
func (f *FakeValidator) AssertGetRSAPubKeysCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) == 0 {
		t.Error("FakeValidator.GetRSAPubKeys not called, expected at least one")
	}
}

// GetRSAPubKeysNotCalled returns true if FakeValidator.GetRSAPubKeys was not called
func (f *FakeValidator) GetRSAPubKeysNotCalled() bool {
	return len(f.GetRSAPubKeysCalls) == 0
}

// AssertGetRSAPubKeysNotCalled calls t.Error if FakeValidator.GetRSAPubKeys was called
func (f *FakeValidator) AssertGetRSAPubKeysNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) != 0 {
		t.Error("FakeValidator.GetRSAPubKeys called, expected none")
	}
}

// GetRSAPubKeysCalledOnce returns true if FakeValidator.GetRSAPubKeys was called exactly once
func (f *FakeValidator) GetRSAPubKeysCalledOnce() bool {
	return len(f.GetRSAPubKeysCalls) == 1
}

// AssertGetRSAPubKeysCalledOnce calls t.Error if FakeValidator.GetRSAPubKeys was not called exactly once
func (f *FakeValidator) AssertGetRSAPubKeysCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) != 1 {
		t.Errorf("FakeValidator.GetRSAPubKeys called %d times, expected 1", len(f.GetRSAPubKeysCalls))
	}
}

// GetRSAPubKeysCalledN returns true if FakeValidator.GetRSAPubKeys was called at least n times
func (f *FakeValidator) GetRSAPubKeysCalledN(n int) bool {
	return len(f.GetRSAPubKeysCalls) >= n
}

// AssertGetRSAPubKeysCalledN calls t.Error if FakeValidator.GetRSAPubKeys was called less than n times
func (f *FakeValidator) AssertGetRSAPubKeysCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) < n {
		t.Errorf("FakeValidator.GetRSAPubKeys called %d times, expected >= %d", len(f.GetRSAPubKeysCalls), n)
	}
}

func (f_sym7 *FakeValidator) ValidateApplicationToken(accessToken string, requiredScopes ...string) (ident1 bool, ident2 error) {
	if f_sym7.ValidateApplicationTokenHook == nil {
		panic("Validator.ValidateApplicationToken() called but FakeValidator.ValidateApplicationTokenHook is nil")
	}

	invocation_sym7 := new(ValidatorValidateApplicationTokenInvocation)
	f_sym7.ValidateApplicationTokenCalls = append(f_sym7.ValidateApplicationTokenCalls, invocation_sym7)

	invocation_sym7.Parameters.AccessToken = accessToken
	invocation_sym7.Parameters.RequiredScopes = requiredScopes

	ident1, ident2 = f_sym7.ValidateApplicationTokenHook(accessToken, requiredScopes...)

	invocation_sym7.Results.Ident1 = ident1
	invocation_sym7.Results.Ident2 = ident2

	return
}

// SetValidateApplicationTokenStub configures Validator.ValidateApplicationToken to always return the given values
func (f_sym8 *FakeValidator) SetValidateApplicationTokenStub(ident1 bool, ident2 error) {
	f_sym8.ValidateApplicationTokenHook = func(string, ...string) (bool, error) {
		return ident1, ident2
	}
}

// SetValidateApplicationTokenInvocation configures Validator.ValidateApplicationToken to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym9 *FakeValidator) SetValidateApplicationTokenInvocation(calls_sym9 []*ValidatorValidateApplicationTokenInvocation, fallback_sym9 func() (bool, error)) {
	f_sym9.ValidateApplicationTokenHook = func(accessToken string, requiredScopes ...string) (ident1 bool, ident2 error) {
		for _, call_sym9 := range calls_sym9 {
			if reflect.DeepEqual(call_sym9.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym9.Parameters.RequiredScopes, requiredScopes) {
				ident1 = call_sym9.Results.Ident1
				ident2 = call_sym9.Results.Ident2

				return
			}
		}

		return fallback_sym9()
	}
}

// ValidateApplicationTokenCalled returns true if FakeValidator.ValidateApplicationToken was called
func (f *FakeValidator) ValidateApplicationTokenCalled() bool {
	return len(f.ValidateApplicationTokenCalls) != 0
}

// AssertValidateApplicationTokenCalled calls t.Error if FakeValidator.ValidateApplicationToken was not called
func (f *FakeValidator) AssertValidateApplicationTokenCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) == 0 {
		t.Error("FakeValidator.ValidateApplicationToken not called, expected at least one")
	}
}

// ValidateApplicationTokenNotCalled returns true if FakeValidator.ValidateApplicationToken was not called
func (f *FakeValidator) ValidateApplicationTokenNotCalled() bool {
	return len(f.ValidateApplicationTokenCalls) == 0
}

// AssertValidateApplicationTokenNotCalled calls t.Error if FakeValidator.ValidateApplicationToken was called
func (f *FakeValidator) AssertValidateApplicationTokenNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) != 0 {
		t.Error("FakeValidator.ValidateApplicationToken called, expected none")
	}
}

// ValidateApplicationTokenCalledOnce returns true if FakeValidator.ValidateApplicationToken was called exactly once
func (f *FakeValidator) ValidateApplicationTokenCalledOnce() bool {
	return len(f.ValidateApplicationTokenCalls) == 1
}

// AssertValidateApplicationTokenCalledOnce calls t.Error if FakeValidator.ValidateApplicationToken was not called exactly once
func (f *FakeValidator) AssertValidateApplicationTokenCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) != 1 {
		t.Errorf("FakeValidator.ValidateApplicationToken called %d times, expected 1", len(f.ValidateApplicationTokenCalls))
	}
}

// ValidateApplicationTokenCalledN returns true if FakeValidator.ValidateApplicationToken was called at least n times
func (f *FakeValidator) ValidateApplicationTokenCalledN(n int) bool {
	return len(f.ValidateApplicationTokenCalls) >= n
}

// AssertValidateApplicationTokenCalledN calls t.Error if FakeValidator.ValidateApplicationToken was called less than n times
func (f *FakeValidator) AssertValidateApplicationTokenCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) < n {
		t.Errorf("FakeValidator.ValidateApplicationToken called %d times, expected >= %d", len(f.ValidateApplicationTokenCalls), n)
	}
}

// ValidateApplicationTokenCalledWith returns true if FakeValidator.ValidateApplicationToken was called with the given values
func (f_sym10 *FakeValidator) ValidateApplicationTokenCalledWith(accessToken string, requiredScopes ...string) bool {
	for _, call_sym10 := range f_sym10.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym10.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym10.Parameters.RequiredScopes, requiredScopes) {
			return true
		}
	}

	return false
}

// AssertValidateApplicationTokenCalledWith calls t.Error if FakeValidator.ValidateApplicationToken was not called with the given values
func (f_sym11 *FakeValidator) AssertValidateApplicationTokenCalledWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var found_sym11 bool
	for _, call_sym11 := range f_sym11.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym11.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym11.Parameters.RequiredScopes, requiredScopes) {
			found_sym11 = true
			break
		}
	}

	if !found_sym11 {
		t.Error("FakeValidator.ValidateApplicationToken not called with expected parameters")
	}
}

// ValidateApplicationTokenCalledOnceWith returns true if FakeValidator.ValidateApplicationToken was called exactly once with the given values
func (f_sym12 *FakeValidator) ValidateApplicationTokenCalledOnceWith(accessToken string, requiredScopes ...string) bool {
	var count_sym12 int
	for _, call_sym12 := range f_sym12.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym12.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym12.Parameters.RequiredScopes, requiredScopes) {
			count_sym12++
		}
	}

	return count_sym12 == 1
}

// AssertValidateApplicationTokenCalledOnceWith calls t.Error if FakeValidator.ValidateApplicationToken was not called exactly once with the given values
func (f_sym13 *FakeValidator) AssertValidateApplicationTokenCalledOnceWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var count_sym13 int
	for _, call_sym13 := range f_sym13.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym13.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym13.Parameters.RequiredScopes, requiredScopes) {
			count_sym13++
		}
	}

	if count_sym13 != 1 {
		t.Errorf("FakeValidator.ValidateApplicationToken called %d times with expected parameters, expected one", count_sym13)
	}
}

// ValidateApplicationTokenResultsForCall returns the result values for the first call to FakeValidator.ValidateApplicationToken with the given values
func (f_sym14 *FakeValidator) ValidateApplicationTokenResultsForCall(accessToken string, requiredScopes ...string) (ident1 bool, ident2 error, found_sym14 bool) {
	for _, call_sym14 := range f_sym14.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym14.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym14.Parameters.RequiredScopes, requiredScopes) {
			ident1 = call_sym14.Results.Ident1
			ident2 = call_sym14.Results.Ident2
			found_sym14 = true
			break
		}
	}

	return
}

func (f_sym15 *FakeValidator) GetAndValidateToken(accessToken string, requiredScopes ...string) (ident1 jwt.JWT, ident2 error) {
	if f_sym15.GetAndValidateTokenHook == nil {
		panic("Validator.GetAndValidateToken() called but FakeValidator.GetAndValidateTokenHook is nil")
	}

	invocation_sym15 := new(ValidatorGetAndValidateTokenInvocation)
	f_sym15.GetAndValidateTokenCalls = append(f_sym15.GetAndValidateTokenCalls, invocation_sym15)

	invocation_sym15.Parameters.AccessToken = accessToken
	invocation_sym15.Parameters.RequiredScopes = requiredScopes

	ident1, ident2 = f_sym15.GetAndValidateTokenHook(accessToken, requiredScopes...)

	invocation_sym15.Results.Ident1 = ident1
	invocation_sym15.Results.Ident2 = ident2

	return
}

// SetGetAndValidateTokenStub configures Validator.GetAndValidateToken to always return the given values
func (f_sym16 *FakeValidator) SetGetAndValidateTokenStub(ident1 jwt.JWT, ident2 error) {
	f_sym16.GetAndValidateTokenHook = func(string, ...string) (jwt.JWT, error) {
		return ident1, ident2
	}
}

// SetGetAndValidateTokenInvocation configures Validator.GetAndValidateToken to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym17 *FakeValidator) SetGetAndValidateTokenInvocation(calls_sym17 []*ValidatorGetAndValidateTokenInvocation, fallback_sym17 func() (jwt.JWT, error)) {
	f_sym17.GetAndValidateTokenHook = func(accessToken string, requiredScopes ...string) (ident1 jwt.JWT, ident2 error) {
		for _, call_sym17 := range calls_sym17 {
			if reflect.DeepEqual(call_sym17.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym17.Parameters.RequiredScopes, requiredScopes) {
				ident1 = call_sym17.Results.Ident1
				ident2 = call_sym17.Results.Ident2

				return
			}
		}

		return fallback_sym17()
	}
}

// GetAndValidateTokenCalled returns true if FakeValidator.GetAndValidateToken was called
func (f *FakeValidator) GetAndValidateTokenCalled() bool {
	return len(f.GetAndValidateTokenCalls) != 0
}

// AssertGetAndValidateTokenCalled calls t.Error if FakeValidator.GetAndValidateToken was not called
func (f *FakeValidator) AssertGetAndValidateTokenCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) == 0 {
		t.Error("FakeValidator.GetAndValidateToken not called, expected at least one")
	}
}

// GetAndValidateTokenNotCalled returns true if FakeValidator.GetAndValidateToken was not called
func (f *FakeValidator) GetAndValidateTokenNotCalled() bool {
	return len(f.GetAndValidateTokenCalls) == 0
}

// AssertGetAndValidateTokenNotCalled calls t.Error if FakeValidator.GetAndValidateToken was called
func (f *FakeValidator) AssertGetAndValidateTokenNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) != 0 {
		t.Error("FakeValidator.GetAndValidateToken called, expected none")
	}
}

// GetAndValidateTokenCalledOnce returns true if FakeValidator.GetAndValidateToken was called exactly once
func (f *FakeValidator) GetAndValidateTokenCalledOnce() bool {
	return len(f.GetAndValidateTokenCalls) == 1
}

// AssertGetAndValidateTokenCalledOnce calls t.Error if FakeValidator.GetAndValidateToken was not called exactly once
func (f *FakeValidator) AssertGetAndValidateTokenCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) != 1 {
		t.Errorf("FakeValidator.GetAndValidateToken called %d times, expected 1", len(f.GetAndValidateTokenCalls))
	}
}

// GetAndValidateTokenCalledN returns true if FakeValidator.GetAndValidateToken was called at least n times
func (f *FakeValidator) GetAndValidateTokenCalledN(n int) bool {
	return len(f.GetAndValidateTokenCalls) >= n
}

// AssertGetAndValidateTokenCalledN calls t.Error if FakeValidator.GetAndValidateToken was called less than n times
func (f *FakeValidator) AssertGetAndValidateTokenCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) < n {
		t.Errorf("FakeValidator.GetAndValidateToken called %d times, expected >= %d", len(f.GetAndValidateTokenCalls), n)
	}
}

// GetAndValidateTokenCalledWith returns true if FakeValidator.GetAndValidateToken was called with the given values
func (f_sym18 *FakeValidator) GetAndValidateTokenCalledWith(accessToken string, requiredScopes ...string) bool {
	for _, call_sym18 := range f_sym18.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym18.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym18.Parameters.RequiredScopes, requiredScopes) {
			return true
		}
	}

	return false
}

// AssertGetAndValidateTokenCalledWith calls t.Error if FakeValidator.GetAndValidateToken was not called with the given values
func (f_sym19 *FakeValidator) AssertGetAndValidateTokenCalledWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var found_sym19 bool
	for _, call_sym19 := range f_sym19.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym19.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym19.Parameters.RequiredScopes, requiredScopes) {
			found_sym19 = true
			break
		}
	}

	if !found_sym19 {
		t.Error("FakeValidator.GetAndValidateToken not called with expected parameters")
	}
}

// GetAndValidateTokenCalledOnceWith returns true if FakeValidator.GetAndValidateToken was called exactly once with the given values
func (f_sym20 *FakeValidator) GetAndValidateTokenCalledOnceWith(accessToken string, requiredScopes ...string) bool {
	var count_sym20 int
	for _, call_sym20 := range f_sym20.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym20.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym20.Parameters.RequiredScopes, requiredScopes) {
			count_sym20++
		}
	}

	return count_sym20 == 1
}

// AssertGetAndValidateTokenCalledOnceWith calls t.Error if FakeValidator.GetAndValidateToken was not called exactly once with the given values
func (f_sym21 *FakeValidator) AssertGetAndValidateTokenCalledOnceWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var count_sym21 int
	for _, call_sym21 := range f_sym21.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym21.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym21.Parameters.RequiredScopes, requiredScopes) {
			count_sym21++
		}
	}

	if count_sym21 != 1 {
		t.Errorf("FakeValidator.GetAndValidateToken called %d times with expected parameters, expected one", count_sym21)
	}
}

// GetAndValidateTokenResultsForCall returns the result values for the first call to FakeValidator.GetAndValidateToken with the given values
func (f_sym22 *FakeValidator) GetAndValidateTokenResultsForCall(accessToken string, requiredScopes ...string) (ident1 jwt.JWT, ident2 error, found_sym22 bool) {
	for _, call_sym22 := range f_sym22.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym22.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym22.Parameters.RequiredScopes, requiredScopes) {
			ident1 = call_sym22.Results.Ident1
			ident2 = call_sym22.Results.Ident2
			found_sym22 = true
			break
		}
	}

	return
}

func (f_sym23 *FakeValidator) ValidateUserToken(accessToken string, requiredScopes ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
	if f_sym23.ValidateUserTokenHook == nil {
		panic("Validator.ValidateUserToken() called but FakeValidator.ValidateUserTokenHook is nil")
	}

	invocation_sym23 := new(ValidatorValidateUserTokenInvocation)
	f_sym23.ValidateUserTokenCalls = append(f_sym23.ValidateUserTokenCalls, invocation_sym23)

	invocation_sym23.Parameters.AccessToken = accessToken
	invocation_sym23.Parameters.RequiredScopes = requiredScopes

	ident1, ident2, ident3, ident4 = f_sym23.ValidateUserTokenHook(accessToken, requiredScopes...)

	invocation_sym23.Results.Ident1 = ident1
	invocation_sym23.Results.Ident2 = ident2
	invocation_sym23.Results.Ident3 = ident3
	invocation_sym23.Results.Ident4 = ident4

	return
}

// SetValidateUserTokenStub configures Validator.ValidateUserToken to always return the given values
func (f_sym24 *FakeValidator) SetValidateUserTokenStub(ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
	f_sym24.ValidateUserTokenHook = func(string, ...string) (uint64, uint64, bool, error) {
		return ident1, ident2, ident3, ident4
	}
}

// SetValidateUserTokenInvocation configures Validator.ValidateUserToken to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym25 *FakeValidator) SetValidateUserTokenInvocation(calls_sym25 []*ValidatorValidateUserTokenInvocation, fallback_sym25 func() (uint64, uint64, bool, error)) {
	f_sym25.ValidateUserTokenHook = func(accessToken string, requiredScopes ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
		for _, call_sym25 := range calls_sym25 {
			if reflect.DeepEqual(call_sym25.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym25.Parameters.RequiredScopes, requiredScopes) {
				ident1 = call_sym25.Results.Ident1
				ident2 = call_sym25.Results.Ident2
				ident3 = call_sym25.Results.Ident3
				ident4 = call_sym25.Results.Ident4

				return
			}
		}

		return fallback_sym25()
	}
}

// ValidateUserTokenCalled returns true if FakeValidator.ValidateUserToken was called
func (f *FakeValidator) ValidateUserTokenCalled() bool {
	return len(f.ValidateUserTokenCalls) != 0
}

// AssertValidateUserTokenCalled calls t.Error if FakeValidator.ValidateUserToken was not called
func (f *FakeValidator) AssertValidateUserTokenCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) == 0 {
		t.Error("FakeValidator.ValidateUserToken not called, expected at least one")
	}
}

// ValidateUserTokenNotCalled returns true if FakeValidator.ValidateUserToken was not called
func (f *FakeValidator) ValidateUserTokenNotCalled() bool {
	return len(f.ValidateUserTokenCalls) == 0
}

// AssertValidateUserTokenNotCalled calls t.Error if FakeValidator.ValidateUserToken was called
func (f *FakeValidator) AssertValidateUserTokenNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) != 0 {
		t.Error("FakeValidator.ValidateUserToken called, expected none")
	}
}

// ValidateUserTokenCalledOnce returns true if FakeValidator.ValidateUserToken was called exactly once
func (f *FakeValidator) ValidateUserTokenCalledOnce() bool {
	return len(f.ValidateUserTokenCalls) == 1
}

// AssertValidateUserTokenCalledOnce calls t.Error if FakeValidator.ValidateUserToken was not called exactly once
func (f *FakeValidator) AssertValidateUserTokenCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) != 1 {
		t.Errorf("FakeValidator.ValidateUserToken called %d times, expected 1", len(f.ValidateUserTokenCalls))
	}
}

// ValidateUserTokenCalledN returns true if FakeValidator.ValidateUserToken was called at least n times
func (f *FakeValidator) ValidateUserTokenCalledN(n int) bool {
	return len(f.ValidateUserTokenCalls) >= n
}

// AssertValidateUserTokenCalledN calls t.Error if FakeValidator.ValidateUserToken was called less than n times
func (f *FakeValidator) AssertValidateUserTokenCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) < n {
		t.Errorf("FakeValidator.ValidateUserToken called %d times, expected >= %d", len(f.ValidateUserTokenCalls), n)
	}
}

// ValidateUserTokenCalledWith returns true if FakeValidator.ValidateUserToken was called with the given values
func (f_sym26 *FakeValidator) ValidateUserTokenCalledWith(accessToken string, requiredScopes ...string) bool {
	for _, call_sym26 := range f_sym26.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym26.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym26.Parameters.RequiredScopes, requiredScopes) {
			return true
		}
	}

	return false
}

// AssertValidateUserTokenCalledWith calls t.Error if FakeValidator.ValidateUserToken was not called with the given values
func (f_sym27 *FakeValidator) AssertValidateUserTokenCalledWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var found_sym27 bool
	for _, call_sym27 := range f_sym27.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym27.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym27.Parameters.RequiredScopes, requiredScopes) {
			found_sym27 = true
			break
		}
	}

	if !found_sym27 {
		t.Error("FakeValidator.ValidateUserToken not called with expected parameters")
	}
}

// ValidateUserTokenCalledOnceWith returns true if FakeValidator.ValidateUserToken was called exactly once with the given values
func (f_sym28 *FakeValidator) ValidateUserTokenCalledOnceWith(accessToken string, requiredScopes ...string) bool {
	var count_sym28 int
	for _, call_sym28 := range f_sym28.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym28.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym28.Parameters.RequiredScopes, requiredScopes) {
			count_sym28++
		}
	}

	return count_sym28 == 1
}

// AssertValidateUserTokenCalledOnceWith calls t.Error if FakeValidator.ValidateUserToken was not called exactly once with the given values
func (f_sym29 *FakeValidator) AssertValidateUserTokenCalledOnceWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var count_sym29 int
	for _, call_sym29 := range f_sym29.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym29.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym29.Parameters.RequiredScopes, requiredScopes) {
			count_sym29++
		}
	}

	if count_sym29 != 1 {
		t.Errorf("FakeValidator.ValidateUserToken called %d times with expected parameters, expected one", count_sym29)
	}
}

// ValidateUserTokenResultsForCall returns the result values for the first call to FakeValidator.ValidateUserToken with the given values
func (f_sym30 *FakeValidator) ValidateUserTokenResultsForCall(accessToken string, requiredScopes ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error, found_sym30 bool) {
	for _, call_sym30 := range f_sym30.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym30.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym30.Parameters.RequiredScopes, requiredScopes) {
			ident1 = call_sym30.Results.Ident1
			ident2 = call_sym30.Results.Ident2
			ident3 = call_sym30.Results.Ident3
			ident4 = call_sym30.Results.Ident4
			found_sym30 = true
			break
		}
	}

	return
}

func (f_sym31 *FakeValidator) GetOpenIDConfig() (ident1 access.OpenIDConfig) {
	if f_sym31.GetOpenIDConfigHook == nil {
		panic("Validator.GetOpenIDConfig() called but FakeValidator.GetOpenIDConfigHook is nil")
	}

	invocation_sym31 := new(ValidatorGetOpenIDConfigInvocation)
	f_sym31.GetOpenIDConfigCalls = append(f_sym31.GetOpenIDConfigCalls, invocation_sym31)

	ident1 = f_sym31.GetOpenIDConfigHook()

	invocation_sym31.Results.Ident1 = ident1

	return
}

// SetGetOpenIDConfigStub configures Validator.GetOpenIDConfig to always return the given values
func (f_sym32 *FakeValidator) SetGetOpenIDConfigStub(ident1 access.OpenIDConfig) {
	f_sym32.GetOpenIDConfigHook = func() access.OpenIDConfig {
		return ident1
	}
}

// GetOpenIDConfigCalled returns true if FakeValidator.GetOpenIDConfig was called
func (f *FakeValidator) GetOpenIDConfigCalled() bool {
	return len(f.GetOpenIDConfigCalls) != 0
}

// AssertGetOpenIDConfigCalled calls t.Error if FakeValidator.GetOpenIDConfig was not called
func (f *FakeValidator) AssertGetOpenIDConfigCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) == 0 {
		t.Error("FakeValidator.GetOpenIDConfig not called, expected at least one")
	}
}

// GetOpenIDConfigNotCalled returns true if FakeValidator.GetOpenIDConfig was not called
func (f *FakeValidator) GetOpenIDConfigNotCalled() bool {
	return len(f.GetOpenIDConfigCalls) == 0
}

// AssertGetOpenIDConfigNotCalled calls t.Error if FakeValidator.GetOpenIDConfig was called
func (f *FakeValidator) AssertGetOpenIDConfigNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) != 0 {
		t.Error("FakeValidator.GetOpenIDConfig called, expected none")
	}
}

// GetOpenIDConfigCalledOnce returns true if FakeValidator.GetOpenIDConfig was called exactly once
func (f *FakeValidator) GetOpenIDConfigCalledOnce() bool {
	return len(f.GetOpenIDConfigCalls) == 1
}

// AssertGetOpenIDConfigCalledOnce calls t.Error if FakeValidator.GetOpenIDConfig was not called exactly once
func (f *FakeValidator) AssertGetOpenIDConfigCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) != 1 {
		t.Errorf("FakeValidator.GetOpenIDConfig called %d times, expected 1", len(f.GetOpenIDConfigCalls))
	}
}

// GetOpenIDConfigCalledN returns true if FakeValidator.GetOpenIDConfig was called at least n times
func (f *FakeValidator) GetOpenIDConfigCalledN(n int) bool {
	return len(f.GetOpenIDConfigCalls) >= n
}

// AssertGetOpenIDConfigCalledN calls t.Error if FakeValidator.GetOpenIDConfig was called less than n times
func (f *FakeValidator) AssertGetOpenIDConfigCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) < n {
		t.Errorf("FakeValidator.GetOpenIDConfig called %d times, expected >= %d", len(f.GetOpenIDConfigCalls), n)
	}
}
