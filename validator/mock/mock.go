// generated by "charlatan -output=./mock/mock.go -package=validatorMock Validator".  DO NOT EDIT.

package validatorMock

import (
	access "github.com/24COMS/go.openid/validator"
	"reflect"
)
import "crypto/rsa"

import "github.com/SermoDigital/jose/jwt"

// ValidatorCloseInvocation represents a single call of FakeValidator.Close
type ValidatorCloseInvocation struct {
	Results struct {
		Ident7 error
	}
}

// ValidatorUpdateKeysInvocation represents a single call of FakeValidator.UpdateKeys
type ValidatorUpdateKeysInvocation struct {
	Results struct {
		Ident1 error
	}
}

// ValidatorGetRSAPubKeysInvocation represents a single call of FakeValidator.GetRSAPubKeys
type ValidatorGetRSAPubKeysInvocation struct {
	Results struct {
		Ident1 []*rsa.PublicKey
	}
}

// ValidatorValidateApplicationTokenInvocation represents a single call of FakeValidator.ValidateApplicationToken
type ValidatorValidateApplicationTokenInvocation struct {
	Parameters struct {
		AccessToken    string
		RequiredScopes []string
	}
	Results struct {
		Ident1 bool
		Ident2 error
	}
}

// NewValidatorValidateApplicationTokenInvocation creates a new instance of ValidatorValidateApplicationTokenInvocation
func NewValidatorValidateApplicationTokenInvocation(accessToken string, requiredScopes []string, ident1 bool, ident2 error) *ValidatorValidateApplicationTokenInvocation {
	invocation := new(ValidatorValidateApplicationTokenInvocation)

	invocation.Parameters.AccessToken = accessToken
	invocation.Parameters.RequiredScopes = requiredScopes

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// ValidatorGetAndValidateTokenInvocation represents a single call of FakeValidator.GetAndValidateToken
type ValidatorGetAndValidateTokenInvocation struct {
	Parameters struct {
		AccessToken    string
		RequiredScopes []string
	}
	Results struct {
		Ident1 jwt.JWT
		Ident2 error
	}
}

// NewValidatorGetAndValidateTokenInvocation creates a new instance of ValidatorGetAndValidateTokenInvocation
func NewValidatorGetAndValidateTokenInvocation(accessToken string, requiredScopes []string, ident1 jwt.JWT, ident2 error) *ValidatorGetAndValidateTokenInvocation {
	invocation := new(ValidatorGetAndValidateTokenInvocation)

	invocation.Parameters.AccessToken = accessToken
	invocation.Parameters.RequiredScopes = requiredScopes

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// ValidatorValidateUserTokenInvocation represents a single call of FakeValidator.ValidateUserToken
type ValidatorValidateUserTokenInvocation struct {
	Parameters struct {
		AccessToken    string
		RequiredScopes []string
	}
	Results struct {
		Ident1 uint64
		Ident2 uint64
		Ident3 bool
		Ident4 error
	}
}

// NewValidatorValidateUserTokenInvocation creates a new instance of ValidatorValidateUserTokenInvocation
func NewValidatorValidateUserTokenInvocation(accessToken string, requiredScopes []string, ident1 uint64, ident2 uint64, ident3 bool, ident4 error) *ValidatorValidateUserTokenInvocation {
	invocation := new(ValidatorValidateUserTokenInvocation)

	invocation.Parameters.AccessToken = accessToken
	invocation.Parameters.RequiredScopes = requiredScopes

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3
	invocation.Results.Ident4 = ident4

	return invocation
}

// ValidatorGetOpenIDConfigInvocation represents a single call of FakeValidator.GetOpenIDConfig
type ValidatorGetOpenIDConfigInvocation struct {
	Results struct {
		Ident1 access.OpenIDConfig
	}
}

// ValidatorTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ValidatorTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeValidator is a mock implementation of Validator for testing.
Use it in your tests as in this example:

	package example

	func TestWithValidator(t *testing.T) {
		f := &validatorMock.FakeValidator{
			CloseHook: func() (ident7 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeClose ...
		f.AssertCloseCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeClose.
*/
type FakeValidator struct {
	CloseHook                    func() error
	UpdateKeysHook               func() error
	GetRSAPubKeysHook            func() []*rsa.PublicKey
	ValidateApplicationTokenHook func(string, ...string) (bool, error)
	GetAndValidateTokenHook      func(string, ...string) (jwt.JWT, error)
	ValidateUserTokenHook        func(string, ...string) (uint64, uint64, bool, error)
	GetOpenIDConfigHook          func() access.OpenIDConfig

	CloseCalls                    []*ValidatorCloseInvocation
	UpdateKeysCalls               []*ValidatorUpdateKeysInvocation
	GetRSAPubKeysCalls            []*ValidatorGetRSAPubKeysInvocation
	ValidateApplicationTokenCalls []*ValidatorValidateApplicationTokenInvocation
	GetAndValidateTokenCalls      []*ValidatorGetAndValidateTokenInvocation
	ValidateUserTokenCalls        []*ValidatorValidateUserTokenInvocation
	GetOpenIDConfigCalls          []*ValidatorGetOpenIDConfigInvocation
}

// NewFakeValidatorDefaultPanic returns an instance of FakeValidator with all hooks configured to panic
func NewFakeValidatorDefaultPanic() *FakeValidator {
	return &FakeValidator{
		CloseHook: func() (ident7 error) {
			panic("Unexpected call to Validator.Close")
		},
		UpdateKeysHook: func() (ident1 error) {
			panic("Unexpected call to Validator.UpdateKeys")
		},
		GetRSAPubKeysHook: func() (ident1 []*rsa.PublicKey) {
			panic("Unexpected call to Validator.GetRSAPubKeys")
		},
		ValidateApplicationTokenHook: func(string, ...string) (ident1 bool, ident2 error) {
			panic("Unexpected call to Validator.ValidateApplicationToken")
		},
		GetAndValidateTokenHook: func(string, ...string) (ident1 jwt.JWT, ident2 error) {
			panic("Unexpected call to Validator.GetAndValidateToken")
		},
		ValidateUserTokenHook: func(string, ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
			panic("Unexpected call to Validator.ValidateUserToken")
		},
		GetOpenIDConfigHook: func() (ident1 access.OpenIDConfig) {
			panic("Unexpected call to Validator.GetOpenIDConfig")
		},
	}
}

// NewFakeValidatorDefaultFatal returns an instance of FakeValidator with all hooks configured to call t.Fatal
func NewFakeValidatorDefaultFatal(t_sym1 ValidatorTestingT) *FakeValidator {
	return &FakeValidator{
		CloseHook: func() (ident7 error) {
			t_sym1.Fatal("Unexpected call to Validator.Close")
			return
		},
		UpdateKeysHook: func() (ident1 error) {
			t_sym1.Fatal("Unexpected call to Validator.UpdateKeys")
			return
		},
		GetRSAPubKeysHook: func() (ident1 []*rsa.PublicKey) {
			t_sym1.Fatal("Unexpected call to Validator.GetRSAPubKeys")
			return
		},
		ValidateApplicationTokenHook: func(string, ...string) (ident1 bool, ident2 error) {
			t_sym1.Fatal("Unexpected call to Validator.ValidateApplicationToken")
			return
		},
		GetAndValidateTokenHook: func(string, ...string) (ident1 jwt.JWT, ident2 error) {
			t_sym1.Fatal("Unexpected call to Validator.GetAndValidateToken")
			return
		},
		ValidateUserTokenHook: func(string, ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
			t_sym1.Fatal("Unexpected call to Validator.ValidateUserToken")
			return
		},
		GetOpenIDConfigHook: func() (ident1 access.OpenIDConfig) {
			t_sym1.Fatal("Unexpected call to Validator.GetOpenIDConfig")
			return
		},
	}
}

// NewFakeValidatorDefaultError returns an instance of FakeValidator with all hooks configured to call t.Error
func NewFakeValidatorDefaultError(t_sym2 ValidatorTestingT) *FakeValidator {
	return &FakeValidator{
		CloseHook: func() (ident7 error) {
			t_sym2.Error("Unexpected call to Validator.Close")
			return
		},
		UpdateKeysHook: func() (ident1 error) {
			t_sym2.Error("Unexpected call to Validator.UpdateKeys")
			return
		},
		GetRSAPubKeysHook: func() (ident1 []*rsa.PublicKey) {
			t_sym2.Error("Unexpected call to Validator.GetRSAPubKeys")
			return
		},
		ValidateApplicationTokenHook: func(string, ...string) (ident1 bool, ident2 error) {
			t_sym2.Error("Unexpected call to Validator.ValidateApplicationToken")
			return
		},
		GetAndValidateTokenHook: func(string, ...string) (ident1 jwt.JWT, ident2 error) {
			t_sym2.Error("Unexpected call to Validator.GetAndValidateToken")
			return
		},
		ValidateUserTokenHook: func(string, ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
			t_sym2.Error("Unexpected call to Validator.ValidateUserToken")
			return
		},
		GetOpenIDConfigHook: func() (ident1 access.OpenIDConfig) {
			t_sym2.Error("Unexpected call to Validator.GetOpenIDConfig")
			return
		},
	}
}

func (f *FakeValidator) Reset() {
	f.CloseCalls = []*ValidatorCloseInvocation{}
	f.UpdateKeysCalls = []*ValidatorUpdateKeysInvocation{}
	f.GetRSAPubKeysCalls = []*ValidatorGetRSAPubKeysInvocation{}
	f.ValidateApplicationTokenCalls = []*ValidatorValidateApplicationTokenInvocation{}
	f.GetAndValidateTokenCalls = []*ValidatorGetAndValidateTokenInvocation{}
	f.ValidateUserTokenCalls = []*ValidatorValidateUserTokenInvocation{}
	f.GetOpenIDConfigCalls = []*ValidatorGetOpenIDConfigInvocation{}
}

func (f_sym3 *FakeValidator) Close() (ident7 error) {
	if f_sym3.CloseHook == nil {
		panic("Validator.Close() called but FakeValidator.CloseHook is nil")
	}

	invocation_sym3 := new(ValidatorCloseInvocation)
	f_sym3.CloseCalls = append(f_sym3.CloseCalls, invocation_sym3)

	ident7 = f_sym3.CloseHook()

	invocation_sym3.Results.Ident7 = ident7

	return
}

// SetCloseStub configures Validator.Close to always return the given values
func (f_sym4 *FakeValidator) SetCloseStub(ident7 error) {
	f_sym4.CloseHook = func() error {
		return ident7
	}
}

// CloseCalled returns true if FakeValidator.Close was called
func (f *FakeValidator) CloseCalled() bool {
	return len(f.CloseCalls) != 0
}

// AssertCloseCalled calls t.Error if FakeValidator.Close was not called
func (f *FakeValidator) AssertCloseCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.CloseCalls) == 0 {
		t.Error("FakeValidator.Close not called, expected at least one")
	}
}

// CloseNotCalled returns true if FakeValidator.Close was not called
func (f *FakeValidator) CloseNotCalled() bool {
	return len(f.CloseCalls) == 0
}

// AssertCloseNotCalled calls t.Error if FakeValidator.Close was called
func (f *FakeValidator) AssertCloseNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.CloseCalls) != 0 {
		t.Error("FakeValidator.Close called, expected none")
	}
}

// CloseCalledOnce returns true if FakeValidator.Close was called exactly once
func (f *FakeValidator) CloseCalledOnce() bool {
	return len(f.CloseCalls) == 1
}

// AssertCloseCalledOnce calls t.Error if FakeValidator.Close was not called exactly once
func (f *FakeValidator) AssertCloseCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.CloseCalls) != 1 {
		t.Errorf("FakeValidator.Close called %d times, expected 1", len(f.CloseCalls))
	}
}

// CloseCalledN returns true if FakeValidator.Close was called at least n times
func (f *FakeValidator) CloseCalledN(n int) bool {
	return len(f.CloseCalls) >= n
}

// AssertCloseCalledN calls t.Error if FakeValidator.Close was called less than n times
func (f *FakeValidator) AssertCloseCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.CloseCalls) < n {
		t.Errorf("FakeValidator.Close called %d times, expected >= %d", len(f.CloseCalls), n)
	}
}

func (f_sym5 *FakeValidator) UpdateKeys() (ident1 error) {
	if f_sym5.UpdateKeysHook == nil {
		panic("Validator.UpdateKeys() called but FakeValidator.UpdateKeysHook is nil")
	}

	invocation_sym5 := new(ValidatorUpdateKeysInvocation)
	f_sym5.UpdateKeysCalls = append(f_sym5.UpdateKeysCalls, invocation_sym5)

	ident1 = f_sym5.UpdateKeysHook()

	invocation_sym5.Results.Ident1 = ident1

	return
}

// SetUpdateKeysStub configures Validator.UpdateKeys to always return the given values
func (f_sym6 *FakeValidator) SetUpdateKeysStub(ident1 error) {
	f_sym6.UpdateKeysHook = func() error {
		return ident1
	}
}

// UpdateKeysCalled returns true if FakeValidator.UpdateKeys was called
func (f *FakeValidator) UpdateKeysCalled() bool {
	return len(f.UpdateKeysCalls) != 0
}

// AssertUpdateKeysCalled calls t.Error if FakeValidator.UpdateKeys was not called
func (f *FakeValidator) AssertUpdateKeysCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.UpdateKeysCalls) == 0 {
		t.Error("FakeValidator.UpdateKeys not called, expected at least one")
	}
}

// UpdateKeysNotCalled returns true if FakeValidator.UpdateKeys was not called
func (f *FakeValidator) UpdateKeysNotCalled() bool {
	return len(f.UpdateKeysCalls) == 0
}

// AssertUpdateKeysNotCalled calls t.Error if FakeValidator.UpdateKeys was called
func (f *FakeValidator) AssertUpdateKeysNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.UpdateKeysCalls) != 0 {
		t.Error("FakeValidator.UpdateKeys called, expected none")
	}
}

// UpdateKeysCalledOnce returns true if FakeValidator.UpdateKeys was called exactly once
func (f *FakeValidator) UpdateKeysCalledOnce() bool {
	return len(f.UpdateKeysCalls) == 1
}

// AssertUpdateKeysCalledOnce calls t.Error if FakeValidator.UpdateKeys was not called exactly once
func (f *FakeValidator) AssertUpdateKeysCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.UpdateKeysCalls) != 1 {
		t.Errorf("FakeValidator.UpdateKeys called %d times, expected 1", len(f.UpdateKeysCalls))
	}
}

// UpdateKeysCalledN returns true if FakeValidator.UpdateKeys was called at least n times
func (f *FakeValidator) UpdateKeysCalledN(n int) bool {
	return len(f.UpdateKeysCalls) >= n
}

// AssertUpdateKeysCalledN calls t.Error if FakeValidator.UpdateKeys was called less than n times
func (f *FakeValidator) AssertUpdateKeysCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.UpdateKeysCalls) < n {
		t.Errorf("FakeValidator.UpdateKeys called %d times, expected >= %d", len(f.UpdateKeysCalls), n)
	}
}

func (f_sym7 *FakeValidator) GetRSAPubKeys() (ident1 []*rsa.PublicKey) {
	if f_sym7.GetRSAPubKeysHook == nil {
		panic("Validator.GetRSAPubKeys() called but FakeValidator.GetRSAPubKeysHook is nil")
	}

	invocation_sym7 := new(ValidatorGetRSAPubKeysInvocation)
	f_sym7.GetRSAPubKeysCalls = append(f_sym7.GetRSAPubKeysCalls, invocation_sym7)

	ident1 = f_sym7.GetRSAPubKeysHook()

	invocation_sym7.Results.Ident1 = ident1

	return
}

// SetGetRSAPubKeysStub configures Validator.GetRSAPubKeys to always return the given values
func (f_sym8 *FakeValidator) SetGetRSAPubKeysStub(ident1 []*rsa.PublicKey) {
	f_sym8.GetRSAPubKeysHook = func() []*rsa.PublicKey {
		return ident1
	}
}

// GetRSAPubKeysCalled returns true if FakeValidator.GetRSAPubKeys was called
func (f *FakeValidator) GetRSAPubKeysCalled() bool {
	return len(f.GetRSAPubKeysCalls) != 0
}

// AssertGetRSAPubKeysCalled calls t.Error if FakeValidator.GetRSAPubKeys was not called
func (f *FakeValidator) AssertGetRSAPubKeysCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) == 0 {
		t.Error("FakeValidator.GetRSAPubKeys not called, expected at least one")
	}
}

// GetRSAPubKeysNotCalled returns true if FakeValidator.GetRSAPubKeys was not called
func (f *FakeValidator) GetRSAPubKeysNotCalled() bool {
	return len(f.GetRSAPubKeysCalls) == 0
}

// AssertGetRSAPubKeysNotCalled calls t.Error if FakeValidator.GetRSAPubKeys was called
func (f *FakeValidator) AssertGetRSAPubKeysNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) != 0 {
		t.Error("FakeValidator.GetRSAPubKeys called, expected none")
	}
}

// GetRSAPubKeysCalledOnce returns true if FakeValidator.GetRSAPubKeys was called exactly once
func (f *FakeValidator) GetRSAPubKeysCalledOnce() bool {
	return len(f.GetRSAPubKeysCalls) == 1
}

// AssertGetRSAPubKeysCalledOnce calls t.Error if FakeValidator.GetRSAPubKeys was not called exactly once
func (f *FakeValidator) AssertGetRSAPubKeysCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) != 1 {
		t.Errorf("FakeValidator.GetRSAPubKeys called %d times, expected 1", len(f.GetRSAPubKeysCalls))
	}
}

// GetRSAPubKeysCalledN returns true if FakeValidator.GetRSAPubKeys was called at least n times
func (f *FakeValidator) GetRSAPubKeysCalledN(n int) bool {
	return len(f.GetRSAPubKeysCalls) >= n
}

// AssertGetRSAPubKeysCalledN calls t.Error if FakeValidator.GetRSAPubKeys was called less than n times
func (f *FakeValidator) AssertGetRSAPubKeysCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.GetRSAPubKeysCalls) < n {
		t.Errorf("FakeValidator.GetRSAPubKeys called %d times, expected >= %d", len(f.GetRSAPubKeysCalls), n)
	}
}

func (f_sym9 *FakeValidator) ValidateApplicationToken(accessToken string, requiredScopes ...string) (ident1 bool, ident2 error) {
	if f_sym9.ValidateApplicationTokenHook == nil {
		panic("Validator.ValidateApplicationToken() called but FakeValidator.ValidateApplicationTokenHook is nil")
	}

	invocation_sym9 := new(ValidatorValidateApplicationTokenInvocation)
	f_sym9.ValidateApplicationTokenCalls = append(f_sym9.ValidateApplicationTokenCalls, invocation_sym9)

	invocation_sym9.Parameters.AccessToken = accessToken
	invocation_sym9.Parameters.RequiredScopes = requiredScopes

	ident1, ident2 = f_sym9.ValidateApplicationTokenHook(accessToken, requiredScopes...)

	invocation_sym9.Results.Ident1 = ident1
	invocation_sym9.Results.Ident2 = ident2

	return
}

// SetValidateApplicationTokenStub configures Validator.ValidateApplicationToken to always return the given values
func (f_sym10 *FakeValidator) SetValidateApplicationTokenStub(ident1 bool, ident2 error) {
	f_sym10.ValidateApplicationTokenHook = func(string, ...string) (bool, error) {
		return ident1, ident2
	}
}

// SetValidateApplicationTokenInvocation configures Validator.ValidateApplicationToken to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym11 *FakeValidator) SetValidateApplicationTokenInvocation(calls_sym11 []*ValidatorValidateApplicationTokenInvocation, fallback_sym11 func() (bool, error)) {
	f_sym11.ValidateApplicationTokenHook = func(accessToken string, requiredScopes ...string) (ident1 bool, ident2 error) {
		for _, call_sym11 := range calls_sym11 {
			if reflect.DeepEqual(call_sym11.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym11.Parameters.RequiredScopes, requiredScopes) {
				ident1 = call_sym11.Results.Ident1
				ident2 = call_sym11.Results.Ident2

				return
			}
		}

		return fallback_sym11()
	}
}

// ValidateApplicationTokenCalled returns true if FakeValidator.ValidateApplicationToken was called
func (f *FakeValidator) ValidateApplicationTokenCalled() bool {
	return len(f.ValidateApplicationTokenCalls) != 0
}

// AssertValidateApplicationTokenCalled calls t.Error if FakeValidator.ValidateApplicationToken was not called
func (f *FakeValidator) AssertValidateApplicationTokenCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) == 0 {
		t.Error("FakeValidator.ValidateApplicationToken not called, expected at least one")
	}
}

// ValidateApplicationTokenNotCalled returns true if FakeValidator.ValidateApplicationToken was not called
func (f *FakeValidator) ValidateApplicationTokenNotCalled() bool {
	return len(f.ValidateApplicationTokenCalls) == 0
}

// AssertValidateApplicationTokenNotCalled calls t.Error if FakeValidator.ValidateApplicationToken was called
func (f *FakeValidator) AssertValidateApplicationTokenNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) != 0 {
		t.Error("FakeValidator.ValidateApplicationToken called, expected none")
	}
}

// ValidateApplicationTokenCalledOnce returns true if FakeValidator.ValidateApplicationToken was called exactly once
func (f *FakeValidator) ValidateApplicationTokenCalledOnce() bool {
	return len(f.ValidateApplicationTokenCalls) == 1
}

// AssertValidateApplicationTokenCalledOnce calls t.Error if FakeValidator.ValidateApplicationToken was not called exactly once
func (f *FakeValidator) AssertValidateApplicationTokenCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) != 1 {
		t.Errorf("FakeValidator.ValidateApplicationToken called %d times, expected 1", len(f.ValidateApplicationTokenCalls))
	}
}

// ValidateApplicationTokenCalledN returns true if FakeValidator.ValidateApplicationToken was called at least n times
func (f *FakeValidator) ValidateApplicationTokenCalledN(n int) bool {
	return len(f.ValidateApplicationTokenCalls) >= n
}

// AssertValidateApplicationTokenCalledN calls t.Error if FakeValidator.ValidateApplicationToken was called less than n times
func (f *FakeValidator) AssertValidateApplicationTokenCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.ValidateApplicationTokenCalls) < n {
		t.Errorf("FakeValidator.ValidateApplicationToken called %d times, expected >= %d", len(f.ValidateApplicationTokenCalls), n)
	}
}

// ValidateApplicationTokenCalledWith returns true if FakeValidator.ValidateApplicationToken was called with the given values
func (f_sym12 *FakeValidator) ValidateApplicationTokenCalledWith(accessToken string, requiredScopes ...string) bool {
	for _, call_sym12 := range f_sym12.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym12.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym12.Parameters.RequiredScopes, requiredScopes) {
			return true
		}
	}

	return false
}

// AssertValidateApplicationTokenCalledWith calls t.Error if FakeValidator.ValidateApplicationToken was not called with the given values
func (f_sym13 *FakeValidator) AssertValidateApplicationTokenCalledWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var found_sym13 bool
	for _, call_sym13 := range f_sym13.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym13.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym13.Parameters.RequiredScopes, requiredScopes) {
			found_sym13 = true
			break
		}
	}

	if !found_sym13 {
		t.Error("FakeValidator.ValidateApplicationToken not called with expected parameters")
	}
}

// ValidateApplicationTokenCalledOnceWith returns true if FakeValidator.ValidateApplicationToken was called exactly once with the given values
func (f_sym14 *FakeValidator) ValidateApplicationTokenCalledOnceWith(accessToken string, requiredScopes ...string) bool {
	var count_sym14 int
	for _, call_sym14 := range f_sym14.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym14.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym14.Parameters.RequiredScopes, requiredScopes) {
			count_sym14++
		}
	}

	return count_sym14 == 1
}

// AssertValidateApplicationTokenCalledOnceWith calls t.Error if FakeValidator.ValidateApplicationToken was not called exactly once with the given values
func (f_sym15 *FakeValidator) AssertValidateApplicationTokenCalledOnceWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var count_sym15 int
	for _, call_sym15 := range f_sym15.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym15.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym15.Parameters.RequiredScopes, requiredScopes) {
			count_sym15++
		}
	}

	if count_sym15 != 1 {
		t.Errorf("FakeValidator.ValidateApplicationToken called %d times with expected parameters, expected one", count_sym15)
	}
}

// ValidateApplicationTokenResultsForCall returns the result values for the first call to FakeValidator.ValidateApplicationToken with the given values
func (f_sym16 *FakeValidator) ValidateApplicationTokenResultsForCall(accessToken string, requiredScopes ...string) (ident1 bool, ident2 error, found_sym16 bool) {
	for _, call_sym16 := range f_sym16.ValidateApplicationTokenCalls {
		if reflect.DeepEqual(call_sym16.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym16.Parameters.RequiredScopes, requiredScopes) {
			ident1 = call_sym16.Results.Ident1
			ident2 = call_sym16.Results.Ident2
			found_sym16 = true
			break
		}
	}

	return
}

func (f_sym17 *FakeValidator) GetAndValidateToken(accessToken string, requiredScopes ...string) (ident1 jwt.JWT, ident2 error) {
	if f_sym17.GetAndValidateTokenHook == nil {
		panic("Validator.GetAndValidateToken() called but FakeValidator.GetAndValidateTokenHook is nil")
	}

	invocation_sym17 := new(ValidatorGetAndValidateTokenInvocation)
	f_sym17.GetAndValidateTokenCalls = append(f_sym17.GetAndValidateTokenCalls, invocation_sym17)

	invocation_sym17.Parameters.AccessToken = accessToken
	invocation_sym17.Parameters.RequiredScopes = requiredScopes

	ident1, ident2 = f_sym17.GetAndValidateTokenHook(accessToken, requiredScopes...)

	invocation_sym17.Results.Ident1 = ident1
	invocation_sym17.Results.Ident2 = ident2

	return
}

// SetGetAndValidateTokenStub configures Validator.GetAndValidateToken to always return the given values
func (f_sym18 *FakeValidator) SetGetAndValidateTokenStub(ident1 jwt.JWT, ident2 error) {
	f_sym18.GetAndValidateTokenHook = func(string, ...string) (jwt.JWT, error) {
		return ident1, ident2
	}
}

// SetGetAndValidateTokenInvocation configures Validator.GetAndValidateToken to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym19 *FakeValidator) SetGetAndValidateTokenInvocation(calls_sym19 []*ValidatorGetAndValidateTokenInvocation, fallback_sym19 func() (jwt.JWT, error)) {
	f_sym19.GetAndValidateTokenHook = func(accessToken string, requiredScopes ...string) (ident1 jwt.JWT, ident2 error) {
		for _, call_sym19 := range calls_sym19 {
			if reflect.DeepEqual(call_sym19.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym19.Parameters.RequiredScopes, requiredScopes) {
				ident1 = call_sym19.Results.Ident1
				ident2 = call_sym19.Results.Ident2

				return
			}
		}

		return fallback_sym19()
	}
}

// GetAndValidateTokenCalled returns true if FakeValidator.GetAndValidateToken was called
func (f *FakeValidator) GetAndValidateTokenCalled() bool {
	return len(f.GetAndValidateTokenCalls) != 0
}

// AssertGetAndValidateTokenCalled calls t.Error if FakeValidator.GetAndValidateToken was not called
func (f *FakeValidator) AssertGetAndValidateTokenCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) == 0 {
		t.Error("FakeValidator.GetAndValidateToken not called, expected at least one")
	}
}

// GetAndValidateTokenNotCalled returns true if FakeValidator.GetAndValidateToken was not called
func (f *FakeValidator) GetAndValidateTokenNotCalled() bool {
	return len(f.GetAndValidateTokenCalls) == 0
}

// AssertGetAndValidateTokenNotCalled calls t.Error if FakeValidator.GetAndValidateToken was called
func (f *FakeValidator) AssertGetAndValidateTokenNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) != 0 {
		t.Error("FakeValidator.GetAndValidateToken called, expected none")
	}
}

// GetAndValidateTokenCalledOnce returns true if FakeValidator.GetAndValidateToken was called exactly once
func (f *FakeValidator) GetAndValidateTokenCalledOnce() bool {
	return len(f.GetAndValidateTokenCalls) == 1
}

// AssertGetAndValidateTokenCalledOnce calls t.Error if FakeValidator.GetAndValidateToken was not called exactly once
func (f *FakeValidator) AssertGetAndValidateTokenCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) != 1 {
		t.Errorf("FakeValidator.GetAndValidateToken called %d times, expected 1", len(f.GetAndValidateTokenCalls))
	}
}

// GetAndValidateTokenCalledN returns true if FakeValidator.GetAndValidateToken was called at least n times
func (f *FakeValidator) GetAndValidateTokenCalledN(n int) bool {
	return len(f.GetAndValidateTokenCalls) >= n
}

// AssertGetAndValidateTokenCalledN calls t.Error if FakeValidator.GetAndValidateToken was called less than n times
func (f *FakeValidator) AssertGetAndValidateTokenCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.GetAndValidateTokenCalls) < n {
		t.Errorf("FakeValidator.GetAndValidateToken called %d times, expected >= %d", len(f.GetAndValidateTokenCalls), n)
	}
}

// GetAndValidateTokenCalledWith returns true if FakeValidator.GetAndValidateToken was called with the given values
func (f_sym20 *FakeValidator) GetAndValidateTokenCalledWith(accessToken string, requiredScopes ...string) bool {
	for _, call_sym20 := range f_sym20.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym20.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym20.Parameters.RequiredScopes, requiredScopes) {
			return true
		}
	}

	return false
}

// AssertGetAndValidateTokenCalledWith calls t.Error if FakeValidator.GetAndValidateToken was not called with the given values
func (f_sym21 *FakeValidator) AssertGetAndValidateTokenCalledWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var found_sym21 bool
	for _, call_sym21 := range f_sym21.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym21.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym21.Parameters.RequiredScopes, requiredScopes) {
			found_sym21 = true
			break
		}
	}

	if !found_sym21 {
		t.Error("FakeValidator.GetAndValidateToken not called with expected parameters")
	}
}

// GetAndValidateTokenCalledOnceWith returns true if FakeValidator.GetAndValidateToken was called exactly once with the given values
func (f_sym22 *FakeValidator) GetAndValidateTokenCalledOnceWith(accessToken string, requiredScopes ...string) bool {
	var count_sym22 int
	for _, call_sym22 := range f_sym22.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym22.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym22.Parameters.RequiredScopes, requiredScopes) {
			count_sym22++
		}
	}

	return count_sym22 == 1
}

// AssertGetAndValidateTokenCalledOnceWith calls t.Error if FakeValidator.GetAndValidateToken was not called exactly once with the given values
func (f_sym23 *FakeValidator) AssertGetAndValidateTokenCalledOnceWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var count_sym23 int
	for _, call_sym23 := range f_sym23.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym23.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym23.Parameters.RequiredScopes, requiredScopes) {
			count_sym23++
		}
	}

	if count_sym23 != 1 {
		t.Errorf("FakeValidator.GetAndValidateToken called %d times with expected parameters, expected one", count_sym23)
	}
}

// GetAndValidateTokenResultsForCall returns the result values for the first call to FakeValidator.GetAndValidateToken with the given values
func (f_sym24 *FakeValidator) GetAndValidateTokenResultsForCall(accessToken string, requiredScopes ...string) (ident1 jwt.JWT, ident2 error, found_sym24 bool) {
	for _, call_sym24 := range f_sym24.GetAndValidateTokenCalls {
		if reflect.DeepEqual(call_sym24.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym24.Parameters.RequiredScopes, requiredScopes) {
			ident1 = call_sym24.Results.Ident1
			ident2 = call_sym24.Results.Ident2
			found_sym24 = true
			break
		}
	}

	return
}

func (f_sym25 *FakeValidator) ValidateUserToken(accessToken string, requiredScopes ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
	if f_sym25.ValidateUserTokenHook == nil {
		panic("Validator.ValidateUserToken() called but FakeValidator.ValidateUserTokenHook is nil")
	}

	invocation_sym25 := new(ValidatorValidateUserTokenInvocation)
	f_sym25.ValidateUserTokenCalls = append(f_sym25.ValidateUserTokenCalls, invocation_sym25)

	invocation_sym25.Parameters.AccessToken = accessToken
	invocation_sym25.Parameters.RequiredScopes = requiredScopes

	ident1, ident2, ident3, ident4 = f_sym25.ValidateUserTokenHook(accessToken, requiredScopes...)

	invocation_sym25.Results.Ident1 = ident1
	invocation_sym25.Results.Ident2 = ident2
	invocation_sym25.Results.Ident3 = ident3
	invocation_sym25.Results.Ident4 = ident4

	return
}

// SetValidateUserTokenStub configures Validator.ValidateUserToken to always return the given values
func (f_sym26 *FakeValidator) SetValidateUserTokenStub(ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
	f_sym26.ValidateUserTokenHook = func(string, ...string) (uint64, uint64, bool, error) {
		return ident1, ident2, ident3, ident4
	}
}

// SetValidateUserTokenInvocation configures Validator.ValidateUserToken to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym27 *FakeValidator) SetValidateUserTokenInvocation(calls_sym27 []*ValidatorValidateUserTokenInvocation, fallback_sym27 func() (uint64, uint64, bool, error)) {
	f_sym27.ValidateUserTokenHook = func(accessToken string, requiredScopes ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error) {
		for _, call_sym27 := range calls_sym27 {
			if reflect.DeepEqual(call_sym27.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym27.Parameters.RequiredScopes, requiredScopes) {
				ident1 = call_sym27.Results.Ident1
				ident2 = call_sym27.Results.Ident2
				ident3 = call_sym27.Results.Ident3
				ident4 = call_sym27.Results.Ident4

				return
			}
		}

		return fallback_sym27()
	}
}

// ValidateUserTokenCalled returns true if FakeValidator.ValidateUserToken was called
func (f *FakeValidator) ValidateUserTokenCalled() bool {
	return len(f.ValidateUserTokenCalls) != 0
}

// AssertValidateUserTokenCalled calls t.Error if FakeValidator.ValidateUserToken was not called
func (f *FakeValidator) AssertValidateUserTokenCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) == 0 {
		t.Error("FakeValidator.ValidateUserToken not called, expected at least one")
	}
}

// ValidateUserTokenNotCalled returns true if FakeValidator.ValidateUserToken was not called
func (f *FakeValidator) ValidateUserTokenNotCalled() bool {
	return len(f.ValidateUserTokenCalls) == 0
}

// AssertValidateUserTokenNotCalled calls t.Error if FakeValidator.ValidateUserToken was called
func (f *FakeValidator) AssertValidateUserTokenNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) != 0 {
		t.Error("FakeValidator.ValidateUserToken called, expected none")
	}
}

// ValidateUserTokenCalledOnce returns true if FakeValidator.ValidateUserToken was called exactly once
func (f *FakeValidator) ValidateUserTokenCalledOnce() bool {
	return len(f.ValidateUserTokenCalls) == 1
}

// AssertValidateUserTokenCalledOnce calls t.Error if FakeValidator.ValidateUserToken was not called exactly once
func (f *FakeValidator) AssertValidateUserTokenCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) != 1 {
		t.Errorf("FakeValidator.ValidateUserToken called %d times, expected 1", len(f.ValidateUserTokenCalls))
	}
}

// ValidateUserTokenCalledN returns true if FakeValidator.ValidateUserToken was called at least n times
func (f *FakeValidator) ValidateUserTokenCalledN(n int) bool {
	return len(f.ValidateUserTokenCalls) >= n
}

// AssertValidateUserTokenCalledN calls t.Error if FakeValidator.ValidateUserToken was called less than n times
func (f *FakeValidator) AssertValidateUserTokenCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.ValidateUserTokenCalls) < n {
		t.Errorf("FakeValidator.ValidateUserToken called %d times, expected >= %d", len(f.ValidateUserTokenCalls), n)
	}
}

// ValidateUserTokenCalledWith returns true if FakeValidator.ValidateUserToken was called with the given values
func (f_sym28 *FakeValidator) ValidateUserTokenCalledWith(accessToken string, requiredScopes ...string) bool {
	for _, call_sym28 := range f_sym28.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym28.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym28.Parameters.RequiredScopes, requiredScopes) {
			return true
		}
	}

	return false
}

// AssertValidateUserTokenCalledWith calls t.Error if FakeValidator.ValidateUserToken was not called with the given values
func (f_sym29 *FakeValidator) AssertValidateUserTokenCalledWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var found_sym29 bool
	for _, call_sym29 := range f_sym29.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym29.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym29.Parameters.RequiredScopes, requiredScopes) {
			found_sym29 = true
			break
		}
	}

	if !found_sym29 {
		t.Error("FakeValidator.ValidateUserToken not called with expected parameters")
	}
}

// ValidateUserTokenCalledOnceWith returns true if FakeValidator.ValidateUserToken was called exactly once with the given values
func (f_sym30 *FakeValidator) ValidateUserTokenCalledOnceWith(accessToken string, requiredScopes ...string) bool {
	var count_sym30 int
	for _, call_sym30 := range f_sym30.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym30.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym30.Parameters.RequiredScopes, requiredScopes) {
			count_sym30++
		}
	}

	return count_sym30 == 1
}

// AssertValidateUserTokenCalledOnceWith calls t.Error if FakeValidator.ValidateUserToken was not called exactly once with the given values
func (f_sym31 *FakeValidator) AssertValidateUserTokenCalledOnceWith(t ValidatorTestingT, accessToken string, requiredScopes ...string) {
	t.Helper()
	var count_sym31 int
	for _, call_sym31 := range f_sym31.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym31.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym31.Parameters.RequiredScopes, requiredScopes) {
			count_sym31++
		}
	}

	if count_sym31 != 1 {
		t.Errorf("FakeValidator.ValidateUserToken called %d times with expected parameters, expected one", count_sym31)
	}
}

// ValidateUserTokenResultsForCall returns the result values for the first call to FakeValidator.ValidateUserToken with the given values
func (f_sym32 *FakeValidator) ValidateUserTokenResultsForCall(accessToken string, requiredScopes ...string) (ident1 uint64, ident2 uint64, ident3 bool, ident4 error, found_sym32 bool) {
	for _, call_sym32 := range f_sym32.ValidateUserTokenCalls {
		if reflect.DeepEqual(call_sym32.Parameters.AccessToken, accessToken) && reflect.DeepEqual(call_sym32.Parameters.RequiredScopes, requiredScopes) {
			ident1 = call_sym32.Results.Ident1
			ident2 = call_sym32.Results.Ident2
			ident3 = call_sym32.Results.Ident3
			ident4 = call_sym32.Results.Ident4
			found_sym32 = true
			break
		}
	}

	return
}

func (f_sym33 *FakeValidator) GetOpenIDConfig() (ident1 access.OpenIDConfig) {
	if f_sym33.GetOpenIDConfigHook == nil {
		panic("Validator.GetOpenIDConfig() called but FakeValidator.GetOpenIDConfigHook is nil")
	}

	invocation_sym33 := new(ValidatorGetOpenIDConfigInvocation)
	f_sym33.GetOpenIDConfigCalls = append(f_sym33.GetOpenIDConfigCalls, invocation_sym33)

	ident1 = f_sym33.GetOpenIDConfigHook()

	invocation_sym33.Results.Ident1 = ident1

	return
}

// SetGetOpenIDConfigStub configures Validator.GetOpenIDConfig to always return the given values
func (f_sym34 *FakeValidator) SetGetOpenIDConfigStub(ident1 access.OpenIDConfig) {
	f_sym34.GetOpenIDConfigHook = func() access.OpenIDConfig {
		return ident1
	}
}

// GetOpenIDConfigCalled returns true if FakeValidator.GetOpenIDConfig was called
func (f *FakeValidator) GetOpenIDConfigCalled() bool {
	return len(f.GetOpenIDConfigCalls) != 0
}

// AssertGetOpenIDConfigCalled calls t.Error if FakeValidator.GetOpenIDConfig was not called
func (f *FakeValidator) AssertGetOpenIDConfigCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) == 0 {
		t.Error("FakeValidator.GetOpenIDConfig not called, expected at least one")
	}
}

// GetOpenIDConfigNotCalled returns true if FakeValidator.GetOpenIDConfig was not called
func (f *FakeValidator) GetOpenIDConfigNotCalled() bool {
	return len(f.GetOpenIDConfigCalls) == 0
}

// AssertGetOpenIDConfigNotCalled calls t.Error if FakeValidator.GetOpenIDConfig was called
func (f *FakeValidator) AssertGetOpenIDConfigNotCalled(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) != 0 {
		t.Error("FakeValidator.GetOpenIDConfig called, expected none")
	}
}

// GetOpenIDConfigCalledOnce returns true if FakeValidator.GetOpenIDConfig was called exactly once
func (f *FakeValidator) GetOpenIDConfigCalledOnce() bool {
	return len(f.GetOpenIDConfigCalls) == 1
}

// AssertGetOpenIDConfigCalledOnce calls t.Error if FakeValidator.GetOpenIDConfig was not called exactly once
func (f *FakeValidator) AssertGetOpenIDConfigCalledOnce(t ValidatorTestingT) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) != 1 {
		t.Errorf("FakeValidator.GetOpenIDConfig called %d times, expected 1", len(f.GetOpenIDConfigCalls))
	}
}

// GetOpenIDConfigCalledN returns true if FakeValidator.GetOpenIDConfig was called at least n times
func (f *FakeValidator) GetOpenIDConfigCalledN(n int) bool {
	return len(f.GetOpenIDConfigCalls) >= n
}

// AssertGetOpenIDConfigCalledN calls t.Error if FakeValidator.GetOpenIDConfig was called less than n times
func (f *FakeValidator) AssertGetOpenIDConfigCalledN(t ValidatorTestingT, n int) {
	t.Helper()
	if len(f.GetOpenIDConfigCalls) < n {
		t.Errorf("FakeValidator.GetOpenIDConfig called %d times, expected >= %d", len(f.GetOpenIDConfigCalls), n)
	}
}
